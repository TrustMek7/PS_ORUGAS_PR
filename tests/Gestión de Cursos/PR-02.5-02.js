import http from 'k6/http';
import { check, sleep } from 'k6';
import { getHeadersWithCSRF } from '../login_token.js';

export const options = {
  vus: 1,           // UN SOLO usuario para acciones masivas individuales
  iterations: 100,  // Restaurar 100 cursos uno por uno
  duration: '10m',  // Tiempo m√°ximo permitido para completar el proceso
};

// Informaci√≥n del administrador para acceder a los cursos
const administrador = {
  email: 'jcusilaymeg@unsa.edu.pe',  // Usuario funcional descubierto
  name: 'Juan Carlos Usilay Mejia',
  institute: 'UNSA'
};

// Variables para m√©tricas de rendimiento
let cursosRestaurados = 0;
let tiempoInicio = Date.now();
let tiemposRespuesta = [];
let cursosEliminadosDisponibles = [];
let errorConsecutivos = 0;

// Funci√≥n para obtener lista de cursos eliminados (en papelera/bin)
function obtenerCursosEliminados() {
  // Intentar obtener cursos desde el bin primero
  const cursosBinUrl = `https://teammates-orugas.appspot.com/webapi/bin/courses`;
  let cursosRes = http.get(cursosBinUrl, { headers: getHeadersWithCSRF() });
  
  // Si no funciona el endpoint del bin, usar el endpoint de softDeleted como fallback
  if (cursosRes.status !== 200) {
    const cursosEliminadosUrl = `https://teammates-orugas.appspot.com/webapi/courses?entitytype=instructor&coursestatus=softDeleted`;
    cursosRes = http.get(cursosEliminadosUrl, { headers: getHeadersWithCSRF() });
  }
  
  if (cursosRes.status === 200 && cursosRes.body) {
    try {
      const cursosData = JSON.parse(cursosRes.body);
      let cursos = [];
      
      // Extraer cursos seg√∫n la estructura de respuesta
      if (Array.isArray(cursosData)) {
        cursos = cursosData;
      } else if (cursosData.courses && Array.isArray(cursosData.courses)) {
        cursos = cursosData.courses;
      } else if (cursosData.data && Array.isArray(cursosData.data)) {
        cursos = cursosData.data;
      } else if (cursosData.deletedCourses && Array.isArray(cursosData.deletedCourses)) {
        cursos = cursosData.deletedCourses;
      } else if (cursosData.softDeletedCourses && Array.isArray(cursosData.softDeletedCourses)) {
        cursos = cursosData.softDeletedCourses;
      }
      
      // Extraer IDs de cursos eliminados
      return cursos.map(curso => {
        if (typeof curso === 'string') return curso;
        return curso.courseId || curso.id || curso.course_id;
      }).filter(id => id && id.length > 0);
      
    } catch (e) {
      console.log(`‚ùå Error procesando lista de cursos eliminados: ${e.message}`);
      return [];
    }
  }
  return [];
}

// Funci√≥n para generar cursos de ejemplo si no hay suficientes eliminados
function generarCursoEliminadoEjemplo(index) {
  const prefijos = ['CS', 'MATH', 'PHY', 'BIO', 'CHEM', 'ENG', 'HIST', 'ECON', 'PSYC', 'ART', 'MED', 'LAW', 'EDU', 'MUSIC', 'SPORT'];
  const prefijo = prefijos[index % prefijos.length];
  return `${prefijo}${101 + Math.floor(index / prefijos.length)}-ADMIN-${index}-${Date.now()}`;
}

export function setup() {
  console.log('üîç Obteniendo lista de cursos eliminados para restaurar...');
  cursosEliminadosDisponibles = obtenerCursosEliminados();
  
  if (cursosEliminadosDisponibles.length > 0) {
    console.log(`‚úÖ Se encontraron ${cursosEliminadosDisponibles.length} cursos eliminados disponibles para restaurar`);
  } else {
    console.log('‚ö†Ô∏è No se encontraron cursos eliminados. Se utilizar√°n IDs de ejemplo para el test.');
    // Generar IDs de ejemplo para testing
    for (let i = 0; i < 100; i++) {
      cursosEliminadosDisponibles.push(generarCursoEliminadoEjemplo(i));
    }
  }
  
  console.log('üéØ Objetivo: Restaurar 100 cursos uno por uno con tiempo ‚â§4s por curso');
  console.log('üìä Evaluando desempe√±o en restauraciones individuales');
  
  return { cursosEliminadosDisponibles };
}

export default function (data) {
  const iterationId = __ITER;
  const totalIteraciones = 100;
  
  // Obtener curso a restaurar
  let cursoId;
  if (data.cursosEliminadosDisponibles && data.cursosEliminadosDisponibles.length > 0) {
    cursoId = data.cursosEliminadosDisponibles[iterationId % data.cursosEliminadosDisponibles.length];
  } else {
    cursoId = generarCursoEliminadoEjemplo(iterationId);
  }
  
  console.log(`üîÑ Restaurando curso ${iterationId + 1}/100: ${cursoId}`);
  
  // URL del endpoint para restaurar curso desde la papelera
  // Basado en el ejemplo proporcionado que usa DELETE para eliminar, 
  // la restauraci√≥n podr√≠a ser el mismo endpoint pero con m√©todo diferente o par√°metro
  const restoreUrl = `https://teammates-orugas.appspot.com/webapi/bin/course?courseid=${encodeURIComponent(cursoId)}&restore=true`;
  
  // Payload para restauraci√≥n - usando DELETE method para restaurar desde bin
  const payload = JSON.stringify({});
  
  const inicioRequest = Date.now();
  const restoreRes = http.del(restoreUrl, payload, { headers: getHeadersWithCSRF() });
  const tiempoRequest = Date.now() - inicioRequest;
  
  tiemposRespuesta.push(tiempoRequest);
  
  // Validaciones espec√≠ficas para acci√≥n masiva de restauraci√≥n individual
  const validaciones = check(restoreRes, {
    '‚úÖ Respuesta HTTP exitosa': (r) => r.status === 200,
    '‚úÖ Acci√≥n r√°pida (‚â§4s por curso)': (r) => tiempoRequest <= 4000,
    '‚úÖ Sin errores del servidor': (r) => r.status !== 500 && r.status !== 502 && r.status !== 503,
    '‚úÖ Autenticaci√≥n v√°lida': (r) => r.status !== 401 && r.status !== 403,
    '‚úÖ Curso encontrado en eliminados': (r) => r.status !== 404,
    '‚úÖ Operaci√≥n permitida': (r) => r.status !== 405 && r.status !== 409,
    '‚úÖ Restauraci√≥n exitosa': (r) => {
      // Verificar que el curso fue restaurado exitosamente
      if (r.status === 200) {
        try {
          // Si hay respuesta JSON, verificar campos de confirmaci√≥n
          if (r.body && r.body.trim() !== '') {
            const response = JSON.parse(r.body);
            // Buscar indicadores de restauraci√≥n exitosa
            return response.restored === true || 
                   response.success === true || 
                   response.status === 'restored' ||
                   response.status === 'active' ||
                   response.message?.includes('restored') ||
                   response.message?.includes('undeleted') ||
                   response.message?.includes('recovered');
          }
          // Si no hay body o est√° vac√≠o, asumir √©xito basado en HTTP 200
          return true;
        } catch {
          // Si no es JSON v√°lido pero status es 200, asumir √©xito
          return true;
        }
      }
      return false;
    },
    '‚úÖ Rendimiento individual √≥ptimo': (r) => tiempoRequest <= 2000, // Meta ideal < 2s
  });

  // An√°lisis de validaciones
  const validacionesExitosas = Object.values(validaciones).filter(v => v === true).length;
  const totalValidaciones = Object.keys(validaciones).length;
  const porcentajeExito = Math.round((validacionesExitosas / totalValidaciones) * 100);

  // Contabilizar cursos restaurados exitosamente
  let realmenteRestaurado = false;
  if (restoreRes.status === 200) {
    try {
      if (restoreRes.body && restoreRes.body.trim() !== '') {
        const response = JSON.parse(restoreRes.body);
        // Verificar indicadores de restauraci√≥n exitosa
        realmenteRestaurado = response.restored === true || 
                             response.success === true || 
                             response.status === 'restored' ||
                             response.status === 'active' ||
                             (response.message && (
                               response.message.includes('restored') ||
                               response.message.includes('undeleted') ||
                               response.message.includes('recovered')
                             ));
      } else {
        // Si no hay body pero status es 200, asumir √©xito
        realmenteRestaurado = true;
      }
    } catch {
      // Si hay error de parsing pero status es 200, asumir √©xito
      realmenteRestaurado = true;
    }
    
    if (realmenteRestaurado) {
      cursosRestaurados++;
      errorConsecutivos = 0;
    }
  } else {
    errorConsecutivos++;
  }
  
  // Log detallado del resultado
  if (restoreRes.status === 200 && realmenteRestaurado) {
    const objetivoTiempo = tiempoRequest <= 4000 ? "‚úÖ CUMPLIDO" : "‚ùå NO CUMPLIDO";
    const rendimientoOptimo = tiempoRequest <= 2000 ? "‚ö° √ìPTIMO" : tiempoRequest <= 4000 ? "‚úÖ BUENO" : "‚ö†Ô∏è LENTO";
    
    console.log(`‚úÖ Curso ${iterationId + 1}/100 restaurado exitosamente en ${tiempoRequest}ms - ${objetivoTiempo}`);
    console.log(`   üìä Rendimiento: ${rendimientoOptimo} | Validaciones: ${validacionesExitosas}/${totalValidaciones} (${porcentajeExito}%)`);
    console.log(`   üîÑ Total restaurados: ${cursosRestaurados}/${iterationId + 1}`);
    
    if (tiempoRequest <= 2000) {
      console.log(`   ‚ö° Excelente: Restauraci√≥n individual en ${tiempoRequest}ms`);
    } else if (tiempoRequest <= 4000) {
      console.log(`   ‚úÖ Aceptable: Restauraci√≥n en ${tiempoRequest}ms (dentro del objetivo)`);
    } else {
      console.log(`   ‚ö†Ô∏è Lento: ${tiempoRequest}ms > 4000ms (objetivo no cumplido)`);
    }
    
  } else {
    console.log(`‚ùå Error restaurando curso ${iterationId + 1}/100 - Status ${restoreRes.status} en ${tiempoRequest}ms`);
    
    if (restoreRes.body) {
      console.log(`   Detalles: ${restoreRes.body.substring(0, 200)}`);
    }
    
    // Mostrar validaciones fallidas
    if (validacionesExitosas < totalValidaciones) {
      console.log(`   ‚ö†Ô∏è Validaciones fallidas:`);
      Object.entries(validaciones).forEach(([nombre, resultado]) => {
        if (!resultado) {
          console.log(`     ‚ùå ${nombre}`);
        }
      });
    }
  }
  
  // M√©tricas de progreso
  const progreso = Math.round(((iterationId + 1) / totalIteraciones) * 100);
  const tiempoTranscurrido = Math.round((Date.now() - tiempoInicio) / 1000);
  const tiempoPromedio = tiemposRespuesta.reduce((a, b) => a + b, 0) / tiemposRespuesta.length;
  const tiempoEstimado = Math.round((tiempoPromedio * (totalIteraciones - iterationId - 1)) / 1000);
  
  console.log(`üìä Progreso: ${progreso}% (${iterationId + 1}/${totalIteraciones}) | Promedio: ${Math.round(tiempoPromedio)}ms | ETA: ${tiempoEstimado}s`);
  
  // Control de errores consecutivos
  if (errorConsecutivos >= 5) {
    console.log(`‚ö†Ô∏è Demasiados errores consecutivos (${errorConsecutivos}). Pausando 2s...`);
    sleep(2);
  } else {
    // Pausa m√≠nima entre restauraciones individuales
    sleep(0.2); // 200ms entre acciones
  }
  
  return {
    iteration: iterationId + 1,
    requestTime: tiempoRequest,
    status: restoreRes.status,
    success: restoreRes.status === 200 && realmenteRestaurado && tiempoRequest <= 4000,
    httpSuccess: restoreRes.status === 200,
    restored: realmenteRestaurado,
    timeObjective: tiempoRequest <= 4000,
    optimalPerformance: tiempoRequest <= 2000,
    courseId: cursoId,
    validationsSuccessful: validacionesExitosas,
    validationsTotal: totalValidaciones,
    validationsPercentage: porcentajeExito,
    validationResults: validaciones,
    consecutiveErrors: errorConsecutivos,
    totalRestored: cursosRestaurados,
    progress: progreso
  };
}

export function handleSummary(data) {
  const stats = {
    checksExitosos: data.metrics.checks?.values.passes || 0,
    checksTotal: data.metrics.checks?.values.count || 0,
    requestsTotal: data.metrics.http_reqs?.values.count || 0,
    duracionPromedio: Math.round(data.metrics.http_req_duration?.values.avg || 0),
    duracionMax: Math.round(data.metrics.http_req_duration?.values.max || 0),
    duracionMin: Math.round(data.metrics.http_req_duration?.values.min || 0),
    iteraciones: data.metrics.iterations?.values.count || 0,
    dataReceived: Math.round((data.metrics.data_received?.values.count || 0) / 1024) // KB
  };
  
  const exitoTotal = stats.checksTotal > 0 ? Math.round((stats.checksExitosos / stats.checksTotal) * 100) : 0;
  const objetivoTiempo = stats.duracionPromedio <= 4000 ? "‚úÖ CUMPLIDO" : "‚ùå NO CUMPLIDO";
  const objetivoCantidad = cursosRestaurados >= 100 ? "‚úÖ CUMPLIDO" : "‚ö†Ô∏è PARCIAL";
  const objetivoGeneral = stats.duracionPromedio <= 4000 && cursosRestaurados >= 80 && exitoTotal >= 80 ? "‚úÖ CUMPLIDO" : "‚ö†Ô∏è REVISAR";
  const rendimientoIndividual = stats.duracionPromedio <= 2000 ? "‚ö° √ìPTIMO" : stats.duracionPromedio <= 4000 ? "‚úÖ BUENO" : "‚ö†Ô∏è MEJORAR";
  
  const tiempoTotalSegundos = Math.round((Date.now() - tiempoInicio) / 1000);
  const throughput = tiempoTotalSegundos > 0 ? Math.round((cursosRestaurados / tiempoTotalSegundos) * 60) : 0; // cursos por minuto

  return {
    'stdout': `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üîÑ PR-02.5-02: ACCI√ìN MASIVA - RESTAURAR INDIVIDUALMENTE CURSOS ELIMINADOS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  üìä VALIDACIONES: ${stats.checksExitosos}/${stats.checksTotal} checks (${exitoTotal}%)
  üîÑ CURSOS RESTAURADOS: ${cursosRestaurados}/100 cursos - ${objetivoCantidad}
  ‚è±Ô∏è TIEMPO POR CURSO: ${stats.duracionPromedio}ms promedio (objetivo: ‚â§4s) ${objetivoTiempo}
  üìà TIEMPOS: ${stats.duracionMin}ms min | ${stats.duracionMax}ms max
  üåê HTTP: ${stats.requestsTotal} requests DELETE realizados
  ‚ö° THROUGHPUT: ${throughput} cursos/minuto
  üïê TIEMPO TOTAL: ${tiempoTotalSegundos}s
  üì¶ DATOS: ${stats.dataReceived}KB transferidos
  üìä RENDIMIENTO INDIVIDUAL: ${rendimientoIndividual}
  üîç ENDPOINT: DELETE /webapi/bin/course?courseid={courseId}&restore=true
  ‚úÖ OBJETIVO GENERAL: ${objetivoGeneral}
  
  üìã M√âTRICAS DETALLADAS:
  ‚Ä¢ Cursos restaurados exitosamente: ${cursosRestaurados}/100
  ‚Ä¢ Tiempo promedio por restauraci√≥n: ${stats.duracionPromedio}ms
  ‚Ä¢ Objetivo de tiempo individual (‚â§4s): ${stats.duracionPromedio <= 4000 ? 'ALCANZADO' : 'NO ALCANZADO'}
  ‚Ä¢ Rendimiento √≥ptimo (‚â§2s): ${stats.duracionPromedio <= 2000 ? 'ALCANZADO' : 'NO ALCANZADO'}
  ‚Ä¢ Variabilidad de tiempo: ${stats.duracionMax - stats.duracionMin}ms
  ‚Ä¢ Throughput de restauraci√≥n: ${throughput} cursos/minuto
  ‚Ä¢ Errores consecutivos m√°ximos: ${errorConsecutivos}
  ‚Ä¢ √âxito de restauraciones individuales: ${cursosRestaurados > 0 ? Math.round((cursosRestaurados / stats.iteraciones) * 100) : 0}%
  
  üéØ RESUMEN DEL OBJETIVO:
  ‚úì Restaurar 100 cursos uno por uno: ${cursosRestaurados >= 100 ? 'COMPLETADO' : `PARCIAL (${cursosRestaurados}/100)`}
  ‚úì Tiempo ‚â§ 4s por curso: ${objetivoTiempo}
  ‚úì Todos los cursos restaurados correctamente: ${cursosRestaurados === stats.iteraciones ? 'S√ç' : 'PARCIAL'}
  ‚úì Evaluar desempe√±o individual: ${rendimientoIndividual}
  ‚úì Operaciones individuales eficientes: ${stats.duracionPromedio <= 4000 && exitoTotal >= 80 ? 'S√ç' : 'REVISAR'}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
`
  };
}